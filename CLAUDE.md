# CLAUDE.md

## Project Overview

Vitalis (OrgVitals) — AI-powered organizational intelligence platform that analyzes email communication graphs to surface health metrics, risks, trends, and AI-generated reports. FastAPI backend + Next.js frontend.

## Commands

### Backend (`backend/`)

```bash
# Install dependencies (uses uv)
cd backend && uv sync

# Run data pipeline (extract → parse → graph → metrics → export JSON)
python -m src.pipeline

# Start API server
uvicorn src.api.main:app --reload --port 8000

# Run tests
pytest
```

### Frontend (`web-app/`)

```bash
# Install dependencies
cd web-app && npm install

# Dev server (port 3000)
npm run dev

# Production build
npm run build

# Lint
npm run lint

# Tests
npm run test            # single run
npm run test:watch      # watch mode
```

## Architecture

```
vitalis/
├── backend/          # Python — FastAPI + NetworkX + OpenAI
│   └── src/
│       ├── api/      # FastAPI app + routes
│       ├── graph/    # Graph construction (NetworkX)
│       ├── metrics/  # Centrality, community, health, waste, DMS
│       ├── parser/   # Email parsing (Enron dataset)
│       ├── sentiment/ # TextBlob sentiment analysis
│       ├── rag/      # ChromaDB embeddings + retrieval for chat/reports
│       └── analysis/ # Role inference from email subjects
├── web-app/          # TypeScript — Next.js 16, React 19, Tailwind CSS 4
│   └── src/
│       ├── app/      # App Router pages
│       ├── components/
│       └── lib/      # API client + types
├── output/           # Pre-computed JSON (generated by pipeline, consumed by API)
└── data/             # Raw dataset
```

**Data flow:** `pipeline.py` processes emails → writes JSON to `output/` → API loads JSON at startup via lifespan → frontend fetches from API.

## Backend

### Entry point

`backend/src/api/main.py` — FastAPI app with lifespan context manager. On startup, `load_data()` reads all JSON from `output/` and calls each route module's `init()` function.

### Module-level `init()` pattern

Route modules use global state initialized at startup instead of dependency injection:

```python
_graph_data: dict | None = None

def init(graph_data: dict, ...):
    global _graph_data
    _graph_data = graph_data
```

Modules initialized: `graph`, `metrics`, `people`, `trends`, `risks`. Chat and reports access RAG dynamically (no init needed).

### API routes

All routes prefixed with `/api`. Base URL: `http://localhost:8000`

| Module | Prefix | Key endpoints |
|--------|--------|---------------|
| `graph` | `/api/graph` | `GET /` full graph, `GET /node/{id}` |
| `metrics` | `/api/metrics` | `GET /overview`, `/centrality?type=`, `/communities`, `/dead-man-switch`, `/waste` |
| `people` | `/api/people` | `GET /` list, `GET /{id}`, `GET /{id}/panel` |
| `chat` | `/api` | `POST /chat` — streaming SSE with OpenAI |
| `reports` | `/api/reports` | `GET /health` — LLM-generated report |
| `trends` | `/api/trends` | `GET /` structural/communication/workstream shifts |
| `risks` | `/api/risks` | `GET /` high-risk nodes, structural risks, waste |

### Pipeline

`python -m src.pipeline` runs 6 steps: extract → parse → build graph → sentiment → compute metrics → export JSON to `output/`.

## Frontend

### App Router structure

```
app/
├── layout.tsx          # Root layout (metadata, fonts)
├── page.tsx            # Landing page (/) with shader animation
└── (app)/              # Route group for main app pages
    ├── layout.tsx      # TopNav + ChatDrawer wrapper
    ├── graph/page.tsx  # Force-directed graph + PersonPanel sidebar
    ├── people/page.tsx # Sortable people directory
    ├── trends/page.tsx # Organizational trends (30-day deltas)
    ├── risks/page.tsx  # Risk dashboard + waste metrics
    └── reports/page.tsx # AI-generated health report
```

### Key files

- `lib/api.ts` — API client. Uses `fetchJson<T>(path)` helper, `cache: "no-store"`. SSE streaming via `streamChat()` async generator. Base URL from `NEXT_PUBLIC_API_URL` env var (default `http://localhost:8000`).
- `lib/types.ts` — All TypeScript interfaces (`GraphNode`, `GraphEdge`, `GraphData`, `MetricsOverview`, `PersonSummary`, `PersonDetail`, `PersonPanel`, `TrendsData`, `RisksData`, etc.).
- `components/layout/TopNav.tsx` — Navigation tabs
- `components/layout/ChatDrawer.tsx` — AI chat sidebar with SSE streaming
- `components/graph/PersonPanel.tsx` — Person detail slide-out panel

### Patterns

- Data fetching: `useEffect` on mount with `useState` for loading/data/error. No React Query or SWR.
- Heavy components (`ForceGraph2D`, `ShaderAnimation`) use `dynamic(() => import(...), { ssr: false })`.
- No global state manager — component-level `useState` only.
- Framer Motion for drawer/panel animations.
- URL query params: `/graph?focus={personId}` to pre-focus a node.

## Key Patterns

- **Pre-computed data:** Pipeline generates JSON; API serves it. No database.
- **Seeded pseudo-random:** Some metrics use deterministic random values for consistent demo responses.
- **Streaming SSE:** Chat endpoint streams `data: {"content": "..."}` lines; frontend consumes via `ReadableStream` + async generator.
- **CORS:** Backend allows `localhost:3000` and `127.0.0.1:3000`.
- **Python ≥ 3.12**, **Node/Next.js 16**, **React 19**, **Tailwind CSS 4**.
